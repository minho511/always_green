2026-1-15
https://wikidocs.net/251990
- 리스트, 튜플, 딕셔너리, 세트, default dict

## 컬렉션 모듈
>`namedtuple`, `deque`, `Counter`, `OrderedDict`, `defaultdict`, `ChainMap`
****
### namedtuple
튜플의 서브클래스로, 각 요소에 이름을 부여할 수 있음. 코드 가독성을 높이고, 인덱스 대신 이름으로 요소에 접근 가능

```python
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])

p = Point(10, 20)

print(p.x) # 10
print(p.y) # 20
```

### deque (double-ended queue)
양쪽 끝에서 빠르게 요소를 추가하고 제거할 수 있는 큐. 리스트와 유사하지만 더 효율적인 큐 연산

```python
from collections import deque

dq = deque(['a', 'b', 'c'])

dq.append('d')
dq.appendleft('z')

dq.pop()
dq.popleft()

print(dq) # deque(['a', 'b', 'c'])
```

### Counter 
요소의 개수를 셀 때 유용한 딕셔너리 서브클래스. 주어진 데이터에서 각 요소의 빈도를 쉽게 계산 가능
```python
from collections import Counter

count = Counter("hello world")

print(count) 

# Counter({'l': 3, 'o': 2, 'h': 1, 'e': 1, ' ': 1, 'w': 1, 'r': 1, 'd': 1})
```

### OrderedDict
순서가 있는 딕셔너리로, 요소가 추가된 순서를 기억. 파이썬 3.7 이상에서는 삽입순서를 유지하지만, 더 명확하고 더 일관된 동작
```python
from collections import OrderedDict

od = OrderedDict()
od['a'] = 1
od['b'] = 2
od['c'] = 3

print(od)
# OrderedDict({'a': 1, 'b': 2, 'c': 3})
```

### ChainMap
여러 딕셔너리를 하나의 뷰로 연결하여 처리. 여러 매핑을 하나의 단일 매핑처럼 취급
```python
from collections import ChainMap

dict1 = {'a':1, 'b':2}
dict2 = {'c':3, 'd':4}

chain = ChainMap(dict1, dict2)

print(chain)
print(chain['a'])
print(chain['c'])
```

## 리스트 컴프리헨션과 제너레이터
> 데이터를 효율적으로 생성하고 처리할 수 있는 도구.
****
### 리스트 컴프리 헨션 (List Comprehension)
기존 리스트를 사용하여 간결하고 직관적인 방식으로 새로운 리스트를 생성. 코드 가독성과 효율성을 높임

**기본 문법**
```python
[표현식 for 항목 in 반복 가능한 객체 if 조건]
```

**예제**
- 숫자의 제곱 리스트 생성
	```python
	squares = [ x**2 for x in range(1, 11)]
	print(squares) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
	```
- 짝수 필터링
	```python
	evens = [x for x in range(1, 11) if x % 2 == 0]
	print(evens) # [2, 4, 6, 8, 10]
	```
- 문자열 길이 리스트 생성
	```python
	words = ["apple", "banana", "cherry"]
	lengths = [len(word) for word in words]
	print(lengths) # [5, 6, 6]
	```
- 중첩된 리스트 컴프리 헨션
	```python
	matrix = [[1,2,3], [4,5,6], [7,8,9]
	flat = [num for row in matrix for num in row]
	print(flat) # [1, 2, 3, 4, 5, 6, 7, 8, 9]
	```

### 제너레이터 (Generator)

이터레이터의 일종으로, 큰 데이터셋을 효율적으로 처리하기 위해 사용됨.
- **모든 값을 미리 계산하여 메모리에 저장하는 대신, 필요한 시점에 값을 하나씩 생성**.
- 메모리 사용을 최적화하고, 대용량 데이터를 처리할 때 매우 유용.

**제너레이터 함수**
`yield` 키워드를 사용하여 정의됨. 값을 반환하지 않고. "생산"함

```python
def count_up_to(max):
    count = 1
    while count <= max:
        yield count
        count += 1

# 제너레이터 객체 생성
counter = count_up_to(5)

# 제너레이터 값 하나씩 출력
for num in counter:
    print(num)
# 1
# 2
# 3
# 4
# 5
```

**제너레이터 표현식**
리스트 컴프리헨션과 유사한 문법. 소괄호`()` 를 사용하여 정의됨. 메모리를 절약하면서도 효율적으로 값을 생성

```python
squares = (x**2 for x in range(1, 11))
for square in squares: print(square)
# 1 4 9  16 ... 100
```

**예제**
- 파일 읽기
	파일의 각 줄을 제너레이터로 읽어 들이는 예제
	```python
	def read_lines(file_path):
		with open(file_path, 'r') as file:
			for line in file:
				yield line.strip()
	
	for line in read_lines('example.txt'):
		print(line)
	```

> 제너레이터를 사용하면 메모리 사용을 최소화하면서도 대용량 데이터를 처리할 수 있음.

