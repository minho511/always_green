2026-1-15
> 객체 지향 프로그래밍 > Object-Oriented Programming, OOP
****

## 클래스와 객체, 여러 용어들

용어 알 필요 있음.
```python
class Person: # 클래스 정의
	species = "Homo sapiens" # 클래스 변수
	
	def __init__(self, name, age): # 생성자(constructor) 메소드
		self.name = name # 인스턴스 변수
		self.age = age # 인스턴스 변수
	
	def greet(self): # 인스턴스 메소드
		print(f"Hello, my name is {self.name} and I am {self.age} years old.")

# 객체 생성
person1 = Person("Alice", 30)
person2 = Person("Bob", 25)

# 메소드 호출
person1.greet() # Hello, my name is Alice and I am 30 years old.
person2.greet() # Hello, my name is Bob and I am 25 years old.

# 클래스 변수 접근
print(person1.species) # Homo sapiens
print(person2.species) # Homo sapiens
```

- 인스턴스 변수와 클래스 변수
	- 인스턴스 변수: 각 객체마다 별도로 유지되는 변수
	- 클래스 변수: 클래스에 속하며 모든 인스턴스가 공유
- 메소드: 클래스 내의 함수
	- 첫번째 매개 변수로 `self` 를 받으며, 호출된 객체를 참조

****
## 정적메소드(@classmethod와 @staticmethod)
참고 : https://wikidocs.net/16074

- 정적메소드란 **클래스에서 직접 접근할 수 있는 메소드** > 인스턴스(객체) 없이 클래스만 있어도 호출 가능함.
- 두가지가 존재 `staticmethod`, `classmethod`, 기능과 용도가 완전히 다른 도구
- 파이썬에서는 다른언어와 다르게 정적메소드임에도 불구하고 인스턴스에서도 접근이 가능함

**결정적 차이** : 자기가 누군지 아는가? (`cls`)
가장 큰 기술적 차이는 첫번째 인자 `cls` 를 받느냐, 안받느냐

`@classmethod` (클래스 메소드)
- 첫번째 인자로 클래스 정보(`cls`)를 무조건 받음.
- `Deep LearningModel` 라는 것을 알고있음. 이 정보를 이용해 새로운 객체(인스턴스)를 생성하거나, 클래스 변수를 수정할 수 있음.
- 주 용도: Factory Method(생성자 대용)
  빈 깡통 모델을 만들지 말고, 미리 학습된 가중치를 넣어서 모델을 생성

`@staticmethod` (정적 메소드)
- `self`, `cls` 아무것도 받지 않음.
- 그냥 입력값 주면 결과값 뱉는 기능만함.
- 주 용도: Utility(단순 도구)

```python
class DeepLearningModel:
	def __init__(self, name):
		self.name = name
	
	@classmethod
	def from_pretrained(cls, model_name):
		print(f"Loading {model_name}...")
		return cls(model_name)
	
	@staticmethod
	def relu(x):
		return max(0, x)
		
# case1
model = DeepLearningModel.from_pretrained("BERT")

# case2
model = DeepLearningModel.relu(-5)
```

|**구분**|**@classmethod**|**@staticmethod**|
|---|---|---|
|**첫 번째 인자**|`cls` (클래스 자신)|없음|
|**자아 인식**|"나는 이 클래스의 메소드다!"라고 인지함|자기가 어디 소속인지 모름 (바보)|
|**언제 쓰는가?**|**생성자**를 커스텀할 때 (`from_csv`, `from_json` 등)|클래스와 관련은 있지만 **독립적인 계산/검증** 로직일 때|
|**상속 시 동작**|자식 클래스에서 호출하면 `cls`가 **자식 클래스**로 바뀜|상속해도 그냥 원래 정의된 그대로 동작함|
**`classmethod` 는 클래스를 조작하거나 객체를 찍어내기 위해쓰고, `staticmethod` 는 그냥 관련 있는 함수를 정리해두기 위해 씀.**

****

2026-1-16
## 상속, 다형성, 캡슐화

> 상속을 통해 코드 재사용성을 높이고, 다형성을 통해 동일한 인터페이스로 다양한 객체를 처리, 캡슐화를 통해 객체 내부 상태를 보호.

#### 상속
 : 기존의 클래스를 재사용해서 새로운 클래스를 정의, 재사용성과 확장성을 높임
 - 다중상속도 가능

#### 다형성(Polymorphism)
: 동일한 인터페이스를 사용하여 다른 데이터 타입을 처리하는 기능, 객체는 동일한 메소드를 호출하더라도, 각 객체의 고유한 동작을 수행
```python
class Animal:
    def speak(self):
        pass # 부모는 껍데기만 제공

class Dog(Animal):
    def speak(self): # 부모의 speak를 덮어씀 (Overriding)
        return "멍멍!"

class Cat(Animal):
    def speak(self): # 부모의 speak를 덮어씀 (Overriding)
        return "야옹~"

# [다형성의 핵심]
# animals 리스트 안에는 개도 있고 고양이도 있습니다.
animals = [Dog(), Cat(), Dog()]

for animal in animals:
    # 나는 animal이 개인지 고양이인지 알 필요가 없음.
    # 그냥 "짖어(speak)"라고 명령하면, 알아서 자기 소리를 냄.
    print(animal.speak())
```
- PyTorch에서 모델을 만들때 항상 `nn.Module` 을 상속받고 `forward` 함수를 구현. 
- 모든 모델은 `forward`라는 공통된 약속(인터페이스)을 지킴.

> `mro()` -> 상속 관계를 확인할 수 있는 메소드

#### 캡슐화(Encapsulation)
- 객체 내부 상태를 외부에서 직접 접근하지 못하도록함
- 공개된 메소드를 통해서만 접근할 수 있도록 하는 개념
- 데이터의 무결성 보호, 객체 상태 제어
```python
class Person:
	def __init__(self, name, age):
		self.__name = name # private 변수
		self.__age = age   # private 변수
	
	def get_name(self):
		return self.__name
	
	def set_name(self, name):
		self.__name = name
	
	def get_age(self):
		return self.__age
	
	def set_age(self, age):
		if 0 <= age <= 120: # 간단한 유효성 검사
			self.__age = age
		else:
			raise ValueError("Invalid age")
	
person = Person("Alice", 30)
print(person.get_name()) # Alice
print(person.get_age()) # 30

person.set_name("Bob")
person.set_age(25)

print(person.get_name()) # Bob
print(person.get_age()) # 25

print(person.__name) 
# **AttributeError**: 'Person' object has no attribute '__name'
```
- `Person` 클래스의 `__name` 과 `__age` 변수를 private 변수로 정의하고, `getter` 과 `setter` 메소드를 통해서만 접근할 수 있도록 하여 캡슐화를 구현.

****

## 특수 메소드

- 특수 메소드(Special Methods)는 파이썬의 특정 동작을 구현하기 위해(커스터마이징 하기 위해) 정의된 메소드로, 메소드 이름뒤에 더블 언더스코어 `__` 가 붙음.
- 파이썬 인터프리터에 의해 자동으로 호출됨.
- 오버라이딩하여 객체의 동작을 재정의 할 수 있음.
- vs 일반 메소드
	- 일반 메소드는 객체의 동작을 정의하고, 특수 메소드는 파이선의 특정 동작을 커스터마이징 할 수 있게 함. 
	-  특수 메소드를 오버라이딩하여 객체의 동작을 재정의하고 보다 직관적인 OOP 구현이 가능함.
### `__init__` 메소드
: 객체가 생성될 때 호출되는 생성자 메소드. 객체 초기화 담당

### `__str__` 메소드
: 객체의 문자열 표현을 정의. `print` 함수나 `str` 함수에 의해 호출됨.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"{self.name}, {self.age}"

# 객체 생성 및 메소드 호출
person = Person("Alice", 30)
print(person)  # Alice, 30

```

### `__repr__`메소드
: 객체의 공식적인 문자열 표현을 정의 `repr` 함수나 인터프리터 프롬프트에서 호출됨.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f"Person(name={self.name!r}, age={self.age})"

# 객체 생성 및 메소드 호출
person = Person("Alice", 30)
print(repr(person))  # Person(name='Alice', age=30)

```

`!r` 은 f-string 안에서 변수를 문자열로 바꿀 때, `__str__()` 대신 `__repr__()` 을 사용하라는 일종의 **변환 플래그**
> "문자열에 따옴표를 붙여서 출력해줘" 라는 뜻
> 따옴표가 붙어 출력된 문자열은 복사 붙여넣기하여 코드로 써도 유효하니까

#### `__eq__`메소드
: 객체 간의 동등성을 정의 `==` 연산자에 의해 호출됨.

```python
class Person:
	def __init__(self, name, age):
		self.name = name
		self.age = age
	
	def __eq__(self, other):
		if isinstance(other, Person):
			return self.name == other.name and self.age == other.age
		return False

person1 = Person("Alice", 30)
person2 = Person("Alice", 30)
print(person1 == person2) # True
```

#### `__lt__`메소드
: `__lt__`메소드는 객체 간의 순서를 정의. `<` 연산자에 의해 호출됨.

```python
class Person:
	def __init__(self, name, age):
		self.name = name
		self.age = age
	
	def __lt__(self, other):
		if isinstance(other, Person):
			return self.age < other.age
		return NotImplemented
	

person1 = Person("Alice", 30)
person2 = Person("Bob", 25)
print(person1 < person2) # False
```

#### `__add__` 메소드
: 두 객체 간의 덧셈을 정의. `+` 연산자에 의해 호출됨.

```python
class Person:
	def __init__(self, name, age):
		self.name = name
		self.age = age
	
	def __add__(self, other):
		if isinstance(other, Person):
			return self.age + other.age
		return NotImplemented
	

person1 = Person("Alice", 30)
person2 = Person("Bob", 25)
print(person1 + person2) # 55
```

***



